#ifndef RENDERPROPERTIES_H
#define RENDERPROPERTIES_H
#pragma region Includes
#include "OGLInterface.h"
#pragma endregion
namespace OmniOGL
{
#pragma region Operations
    #pragma region StencilFunction Class
    class StencilFunction
    {
    public:
        /// <summary>A boolean value which determines whether or not stencil tests are enabled at the time the object is rendered. The stencil buffer is essentially a buffer where you can store a rendered
        /// frame or an image, etc. and then compare each newly rendered frame against whatever is in the stencil buffer, potentially changing/discarding a fragment from the frame as a result.</summary>
        /// <remarks>Initilzied to false by default. Stencil tests/buffer should be disabled at all times except immediately before and during usage.</remarks>
        bool enabled;
        /// <summary>An integer which should only be set to a value between 0x00 and 0xFF. This value is used as a mask which determines which bits can be written to the stencil buffer. A binary 1
        /// indicates that a bit can be written to.</summary>
        /// <remarks>Initialized to 0xFF by default so that all stencil bits can be written to, should the stencil buffer be enabled.</remarks>
        GLint mask;
        /// <summary>Three integers which represent the operation, reference, and a mask. The operation must be one of the enumerations: GL_NEVER, GL_ALWAYS, GL_EQUAL, GL_NOTEQUAL,
        /// GL_LESS, GL_LEQUAL, GL_GEQUAL, or GL_GREATER. The operation specifies under what condition the stencil test passes i.e. GL_NEVER will never pass and GL_EQUAL will pass when the stencil
        /// bit is equal to the reference integer. The reference is an integer to which the operation is in reference to. In other words, it's the number that the stencil value has to be "equal to" or
        /// "greater than". The mask is a value between 0x00 and 0xFF which is bitwise ANDed with both the reference integer and the incoming stencil value.
        /// <seealso cref="RenObj::stencil_op"/></summary>
        /// <remarks>Initialized to [GL_EQUAL, 1, 0xFF], since that is a somewhat common configuration.</remarks>
        GLint function[3];
        /// <summary>Three integers which determine what will happen should the stencil function pass. All three elements must be one of the following enumerations: GL_KEEP, GL_ZERO,
        /// GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, or GL_INVERT. The first element determines what will happen should the stencil test fail. The second element describes
        /// what will happen should the stencil test pass, but the depth test failed (for a particular fragment). The third element determines what will happen should both tests pass.
        /// <seealso cref="RenObj::stencil_func"/></summary>
        /// <remarks>Initialized to [GL_REPLACE,GL_KEEP,GL_KEEP] which results in the most basic behavior.</remarks>
        GLint operation[3];
        StencilFunction(void);
    };
    #pragma endregion
    #pragma region DepthFunction Class
    class DepthFunction
    {
    public:
        /// <summary>A boolean value which determines whether or not depth testing will be enabled for the object when it is the object's turn to be rendered. If this boolean value is set to true then
        /// objects in the player's line-of-sight clip other objects of contrasting depth as specified by the depth function and depth mask. This should be enabled for most all 3D objects.
        /// <seealso cref="RenObj::depth_func"/><seealso cref="RenObj::depth_mask"/></summary>
        /// <remarks>Initialized to true in the RenObj constructor since depth testing will be desired more often than not.</remarks>
        bool enabled;
        /// <summary>An integer which stores an enumeration representing under what condition the the depth test will pass. As of 4/2/13 the options are GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER,
        /// GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS.</summary>
        /// <remarks>Initialized to GL_LEQUAL by default, which means that the fragments generated by the fragment shader which are closest to the player will be the fragments which will be visible. Ties in
        /// this case would go to whichever fragment was rendered last.</remarks>
        GLint function;
        /// <summary>An integer which stores an enumeration which represents a binary value. The possible choices are GL_FALSE, which disables writing to the depth buffer, and GL_ALWAYS, which enables
        /// continuous writing to the depth buffer. I'm not 100% certain on the purpose of setting this to GL_FALSE as opposed to just disabling depth testing, but it might serve some use in the future.</summary>
        /// <remarks>Initialized to GL_ALWAYS by default and never changes.</remarks>
        GLboolean mask;
        DepthFunction(void);
    };
    #pragma endregion
    #pragma region BlendFunction Class
    class BlendFunction
    {
    public:
        /// <summary>A boolean value which determines whether or not blending is enabled. Blending is an advanced technique which blends fragments with colors in the blending buffer, according to a specified
        /// function. Blending can, for example, make 3D objects appear transparent.</summary>
        /// <remarks>I don't believe I've implemented blending yet in any fashion. For now this should ALWAYS BE FALSE. Put it on the to-do list. =]</remarks>
        bool enabled;
        /// <summary>Two integers which must be one of the following enumerations: GL_FUNC_ADD?, GL_FUNC_SUBTRACT?, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, or GL_MAX. These two integers determine what equation is used
        /// to blend the source and destination fragments. The first integer is applied to rgb values while the second integer is applied to the alpha component.</summary>
        /// <remarks>Both elements in this fixed array are intialized to -1. This is unlike all of the other similar functions which are initialized with "ready to render" default values.</remarks>
        GLint function[2];
        BlendFunction(void);
    };
    #pragma endregion
#pragma endregion
#pragma region Material Properties
    #pragma region MaterialLighting Class
    class MaterialLighting
    {
    public:
        bool enabled;
        /// <summary>Used to force an object to all black. Currently this is used to force text to all black should the font size be too small, since in the current
        /// implementation of rendering text there is a white border around black text.</summary>
        /// <remarks>Initialized to <c>False</c> by default.</remarks>
        bool black_only;
        /// <summary>Four floats which represent the r,g,b and alpha diffuse factors. Each factor should be a number between 0.0 and 1.0, as they are essentially a percentage that imply "this percentage
        /// of the r,g,b, or a component of diffuse lighting that 'hits' this object will be visible".<seealso cref="RenObj::factor_vec4()"/></summary>
        /// <remarks>Each element is initialized to 1.0 by default, which means the object will show 100% of the diffuse lighting "cast upon" it. Diffuse lighting generally looks soft and gradual.</remarks>
        GLfloat diffuse_factor[4];
        /// <summary>Four floats which represent the r,g,b and alpha specular factors. Each factor should be a number between 0.0 and 1.0, as they are essentially a percentage that imply "this percentage
        /// of the r,g,b, or a component of specular lighting that 'hits' this object will be visible". Specular lighting is synonmous with "Phong Shading" in this rendering engine.
        /// <seealso cref="RenObj::factor_vec4()"/></summary>
        /// <remarks>Each member is initialized to 1.0 by default, which means the object will show 100% of the specular lighting "cast upon" it. Specular lighting generally looks shiny and reflective.</remarks>
        GLfloat specular_factor[4];
        /// <summary>A single GLfloat which ultimately ends up being an exponent when calculating specular lighting in the fragment shader. Increase this number to make the specular reflection tighter,
        /// brighter, and more concise - almost as if it were perfectly reflecting a spherical light source. Decrease the number to broaden the effect.</summary>
        /// <remarks>Initialized to 100 in the MaterialLighting default constructor. (100 was an arbitrary pick.)</remarks>
        GLfloat shininess;
        MaterialLighting(void);
        void Update(OGLUniforms & uniforms_in);
        static void StaticUpdate(OGLUniforms & uniforms_in);
    };
    #pragma endregion
    #pragma region TextureMaster Class
    class TextureMaster
    {
        friend class RenObj; friend class Scene;
    private:
        static bool textures_enabled;
        static GLint active_texture_index;
        /// <summary>An array of unsigned integers which store the indices generated via <c>RenObj::MakeTexture()</c>. This array of indices serves as the primary means for referencing a
        /// texture at a time after it was initially bound.<seealso cref="RenObj::MakeTexture()"/><seealso cref="RenObj::SetTexture()"/></summary>
        /// <remarks>For simplicity's sake, the size of this array is static. In the future, a more flexible implementation might size this array according to the actual maximum number of
        /// textures supported by the graphics card of the system on which the program is run.</remarks>
        static GLuint textures[MAX_TEX];
        /// <summary>An array of paths of the picture files which have already been loaded into a texture. These paths are stored each time a texture is created so-as to prevent accidentally
        /// assigning the same file to multiple texture "slots".
        /// <seealso cref="RenObj::MakeTexture()"/></summary>
        /// <remarks>For simplicity's sake, the size of this array is static. In the future, a more flexible implementation might size this array according to the actual maximum number of
        /// textures supported by the graphics card of the system on which the program is run.</remarks>
        static std::string filenames[MAX_TEX];
        /// <summary>An integer which keeps track of the index of the next texture, should one be assigned. This variable inherently also represents the number of textures that have already
        /// been bound to memory.</summary>
        /// <remarks>Initialized in RenObj.cpp to 0..</remarks>
        static GLint index;
        /// <summary>A static method which takes the path to a picture file as a parameter, uses the SOIL library to load the picture into local memory, then generates, activates, and binds
        /// a texture in the shader program. The index of the texture is stored in a static member so that the texture can be referenced later.
        /// <seealso cref="RenObj::tex"/><seealso cref="RenObj::SetTexture()"/></summary>
        /// <param name="file_in">A string representing a file path for the texture image which is desired. If the file path has already been bound to a texture then the appropriate
        /// texture index will be used and no new texture will be bound.</param>
        /// <param name="repeat">A boolean value which determines whether or not the texture is tiled (repeated) or stretched.</param>
        /// <returns>Provided there were no errors, returns the texture index used, regardless if a new texture was bound or not. Errors will result in a return value of -1.</returns>
        static GLint MakeTexture(std::string file_in,bool repeat);
        static GLint FreeTextures(void);
    public:
        static GLint CurrentTextureIndex(void);
        static void SetCurrentTextureIndex(GLint texture_in);
        static bool TexturesEnabled(void);
        static void SetTexturesEnabled(bool enabled_in);
    };
    #pragma endregion
#pragma endregion
}
#endif